---
navigation_title: "SSL/TLS"
mapped_pages:
  - https://www.elastic.co/guide/en/fleet/current/elastic-agent-ssl-configuration.html
---

# Configure SSL/TLS for standalone {{agent}}s [elastic-agent-ssl-configuration]


There are a number of SSL configuration settings available depending on whether you are configuring a client, server, or both. See the following tables for available settings:

* [Table 7, Common configuration options](#common-ssl-options). These settings are valid in both client and server configurations.
* [Table 8, Client configuration options](#client-ssl-options)
* [Table 9, Server configuration options](#server-ssl-options)

::::{tip}
For more information about using certificates, refer to [Secure connections](/reference/ingestion-tools/fleet/secure.md).
::::


$$$common-ssl-options$$$

| Setting | Description |
| --- | --- |
| $$$ssl.ca_sha256-common-setting$$$<br>`ssl.ca_sha256`<br> | (string) This configures a certificate pin that you can use to ensure that a specific certificate is part of the verified chain.<br><br>The pin is a base64 encoded string of the SHA-256 of the certificate.<br><br>::::{note} <br>This check is not a replacement for the normal SSL validation, but it adds additional validation. If this setting is used with  `verification_mode` set to `none`, the check will always fail because it will not receive any verified chains.<br>::::<br><br> |
| $$$ssl.cipher_suites-common-setting$$$<br>`ssl.cipher_suites`<br> | (list) The list of cipher suites to use. The first entry has the highest priority. If this option is omitted, the Go crypto library’s [default suites](https://golang.org/pkg/crypto/tls/) are used (recommended). Note that TLS 1.3 cipher suites are not individually configurable in Go, so they are not included in this list.<br><br>The following cipher suites are available:<br><br>* ECDHE-ECDSA-AES-128-CBC-SHA<br>* ECDHE-ECDSA-AES-128-CBC-SHA256: TLS 1.2 only. Disabled by default.<br>* ECDHE-ECDSA-AES-128-GCM-SHA256: TLS 1.2 only.<br>* ECDHE-ECDSA-AES-256-CBC-SHA<br>* ECDHE-ECDSA-AES-256-GCM-SHA384: TLS 1.2 only.<br>* ECDHE-ECDSA-CHACHA20-POLY1305: TLS 1.2 only.<br>* ECDHE-ECDSA-RC4-128-SHA: Disabled by default. RC4 not recommended.<br>* ECDHE-RSA-3DES-CBC3-SHA<br>* ECDHE-RSA-AES-128-CBC-SHA<br>* ECDHE-RSA-AES-128-CBC-SHA256: TLS 1.2 only. Disabled by default.<br>* ECDHE-RSA-AES-128-GCM-SHA256: TLS 1.2 only.<br>* ECDHE-RSA-AES-256-CBC-SHA<br>* ECDHE-RSA-AES-256-GCM-SHA384: TLS 1.2 only.<br>* ECDHE-RSA-CHACHA20-POLY1205: TLS 1.2 only.<br>* ECDHE-RSA-RC4-128-SHA: Disabled by default. RC4 not recommended.<br>* RSA-3DES-CBC3-SHA<br>* RSA-AES-128-CBC-SHA<br>* RSA-AES-128-CBC-SHA256: TLS 1.2 only. Disabled by default.<br>* RSA-AES-128-GCM-SHA256: TLS 1.2 only.<br>* RSA-AES-256-CBC-SHA<br>* RSA-AES-256-GCM-SHA384: TLS 1.2 only.<br>* RSA-RC4-128-SHA: Disabled by default. RC4 not recommended.<br><br>Here is a list of acronyms used in defining the cipher suites:<br><br>* 3DES: Cipher suites using triple DES<br>* AES-128/256: Cipher suites using AES with 128/256-bit keys.<br>* CBC: Cipher using Cipher Block Chaining as block cipher mode.<br>* ECDHE: Cipher suites using Elliptic Curve Diffie-Hellman (DH) ephemeral key exchange.<br>* ECDSA: Cipher suites using Elliptic Curve Digital Signature Algorithm for authentication.<br>* GCM: Galois/Counter mode is used for symmetric key cryptography.<br>* RC4: Cipher suites using RC4.<br>* RSA: Cipher suites using RSA.<br>* SHA, SHA256, SHA384: Cipher suites using SHA-1, SHA-256 or SHA-384.<br> |
| $$$ssl.curve_types-common-setting$$$<br>`ssl.curve_types`<br> | (list) The list of curve types for ECDHE (Elliptic Curve Diffie-Hellman ephemeral key exchange).<br><br>The following elliptic curve types are available:<br><br>* P-256<br>* P-384<br>* P-521<br>* X25519<br> |
| $$$ssl.enabled-common-setting$$$<br>`ssl.enabled`<br> | (boolean) Enables or disables the SSL configuration.<br><br>**Default:** `true`<br><br>::::{note} <br>SSL settings are disabled if either `enabled` is set to `false` or the `ssl` section is missing.<br>::::<br><br> |
| $$$ssl.supported_protocols-common-setting$$$<br>`ssl.supported_protocols`<br> | (list) List of allowed SSL/TLS versions. If the SSL/TLS server supports none of the specified versions, the connection will be dropped during or after the handshake. The list of allowed protocol versions include: `TLSv1.1`, `TLSv1.2`, and `TLSv1.3`.<br><br>**Default:** `[TLSv1.2, TLSv1.3]`<br> |

$$$client-ssl-options$$$

| Setting | Description |
| --- | --- |
| $$$ssl.certificate-client-setting$$$<br>`ssl.certificate`<br> | (string) The path to the certificate for SSL client authentication. This setting is only required if `client_authentication` is specified. If `certificate` is not specified, client authentication is not available, and the connection might fail if the server requests client authentication. If the SSL server does not require client authentication, the certificate will be loaded, but not requested or used by the server.<br><br>Example:<br><br>```yaml<br>ssl.certificate: "/path/to/cert.pem"<br>```<br><br>When this setting is configured, the `ssl.key` setting is also required.<br><br>Specify a path, or embed a certificate directly in the `YAML` configuration:<br><br>```yaml<br>ssl.certificate: &#124;<br>    -----BEGIN CERTIFICATE-----<br>    CERTIFICATE CONTENT APPEARS HERE<br>    -----END CERTIFICATE-----<br>```<br> |
| $$$ssl.certificate_authorities-client-setting$$$<br>`ssl.certificate` `_authorities`<br> | (list) The list of root certificates for verifications (required). If `certificate_authorities` is empty or not set, the system keystore is used. If `certificate_authorities` is self-signed, the host system needs to trust that CA cert as well.<br><br>Example:<br><br>```yaml<br>ssl.certificate_authorities: ["/path/to/root/ca.pem"]<br>```<br><br>Specify a list of files that {{agent}} will read, or embed a certificate directly in the `YAML` configuration:<br><br>```yaml<br>ssl.certificate_authorities:<br>  - &#124;<br>    -----BEGIN CERTIFICATE-----<br>    CERTIFICATE CONTENT APPEARS HERE<br>    -----END CERTIFICATE-----<br>```<br> |
| $$$ssl.key-client-setting$$$<br>`ssl.key`<br> | (string) The client certificate key used for client authentication. Only required if `client_authentication` is configured.<br><br>Example:<br><br>```yaml<br>ssl.key: "/path/to/cert.key"<br>```<br><br>Specify a path, or embed the private key directly in the `YAML` configuration:<br><br>```yaml<br>ssl.key: &#124;<br>    -----BEGIN PRIVATE KEY-----<br>    KEY CONTENT APPEARS HERE<br>    -----END PRIVATE KEY-----<br>```<br> |
| $$$ssl.key_passphrase-client-setting$$$<br>`ssl.key_passphrase`<br> | (string) The passphrase used to decrypt an encrypted key stored in the configured `key` file.<br> |
| $$$ssl.verification_mode-client-setting$$$<br>`ssl.verification` `_mode`<br> | (string) Controls the verification of server certificates. Valid values are:<br><br>`full`<br>:   Verifies that the provided certificate is signed by a trusted authority (CA) and also verifies that the server’s hostname (or IP address) matches the names identified within the certificate.<br><br>`strict`<br>:   Verifies that the provided certificate is signed by a trusted authority (CA) and also verifies that the server’s hostname (or IP address) matches the names identified within the certificate. If the Subject Alternative Name is empty, it returns an error.<br><br>`certificate`<br>:   Verifies that the provided certificate is signed by a trusted authority (CA), but does not perform any hostname verification.<br><br>`none`<br>:   Performs *no verification* of the server’s certificate. This mode disables many of the security benefits of SSL/TLS and should only be used after cautious consideration. It is primarily intended as a temporary diagnostic mechanism when attempting to resolve TLS errors; its use in production environments is strongly discouraged.<br><br>**Default:** `full`<br> |
| $$$ssl.ca_trusted_fingerprint$$$<br>`ssl.ca_trusted` `_fingerprint`<br> | (string) A HEX encoded SHA-256 of a CA certificate. If this certificate is present in the chain during the handshake, it will be added to the `certificate_authorities` list and the handshake will continue normally.<br><br>Example:<br><br>```yaml<br>ssl.ca_trusted_fingerprint: 3b24d33844d6553...826<br>```<br> |

$$$server-ssl-options$$$

| Setting | Description |
| --- | --- |
| $$$ssl.certificate-server-setting$$$<br>`ssl.certificate`<br> | (string) The path to the certificate for SSL server authentication. If the certificate is not specified, startup will fail.<br><br>Example:<br><br>```yaml<br>ssl.certificate: "/path/to/server/cert.pem"<br>```<br><br>When this setting is configured, the `key` setting is also required.<br><br>Specify a path, or embed a certificate directly in the `YAML` configuration:<br><br>```yaml<br>ssl.certificate: &#124;<br>    -----BEGIN CERTIFICATE-----<br>    CERTIFICATE CONTENT APPEARS HERE<br>    -----END CERTIFICATE-----<br>```<br> |
| $$$ssl.certificate_authorities-server-setting$$$<br>`ssl.certificate` `_authorities`<br> | (list) The list of root certificates for client verifications is only required if  `client_authentication` is configured. If `certificate_authorities` is empty or not set, and `client_authentication` is configured, the system keystore is used. If `certificate_authorities` is self-signed, the host system needs to trust that CA cert too.<br><br>Example:<br><br>```yaml<br>ssl.certificate_authorities: ["/path/to/root/ca.pem"]<br>```<br><br>Specify a list of files that {{agent}} will read, or embed a certificate directly in the `YAML` configuration:<br><br>```yaml<br>ssl.certificate_authorities:<br>  - &#124;<br>    -----BEGIN CERTIFICATE-----<br>    CERTIFICATE CONTENT APPEARS HERE<br>    -----END CERTIFICATE-----<br>```<br> |
| $$$ssl.client_authentication-server-setting$$$<br>`ssl.client_` `authentication`<br> | (string) Configures client authentication. The valid options are:<br><br>`none`<br>:   Disables client authentication.<br><br>`optional`<br>:   When a client certificate is supplied, the server will verify it.<br><br>`required`<br>:   Requires clients to provide a valid certificate.<br><br>**Default:** `required` (if `certificate_authorities` is set); otherwise, `none`<br> |
| $$$ssl.key-server-setting$$$<br>`ssl.key`<br> | (string) The server certificate key used for authentication (required).<br><br>Example:<br><br>```yaml<br>ssl.key: "/path/to/server/cert.key"<br>```<br><br>Specify a path, or embed the private key directly in the `YAML` configuration:<br><br>```yaml<br>ssl.key: &#124;<br>    -----BEGIN PRIVATE KEY-----<br>    KEY CONTENT APPEARS HERE<br>    -----END PRIVATE KEY-----<br>```<br> |
| $$$ssl.key_passphrase-server-setting$$$<br>`ssl.key_passphrase`<br> | (string) The passphrase used to decrypt an encrypted key stored in the configured `key` file.<br> |
| $$$ssl.renegotiation-server-setting$$$<br>`ssl.renegotiation`<br> | (string) Configures the type of TLS renegotiation to support. The valid options are:<br><br>`never`<br>:   Disables renegotiation.<br><br>`once`<br>:   Allows a remote server to request renegotiation once per connection.<br><br>`freely`<br>:   Allows a remote server to request renegotiation repeatedly.<br><br>**Default:** `never`<br> |
| $$$ssl.verification_mode-server-setting$$$<br>`ssl.verification` `_mode`<br> | (string) Controls the verification of client certificates. Valid values are:<br><br>`full`<br>:   Verifies that the provided certificate is signed by a trusted authority (CA) and also verifies that the server’s hostname (or IP address) matches the names identified within the certificate.<br><br>`strict`<br>:   Verifies that the provided certificate is signed by a trusted authority (CA) and also verifies that the server’s hostname (or IP address) matches the names identified within the certificate. If the Subject Alternative Name is empty, it returns an error.<br><br>`certificate`<br>:   Verifies that the provided certificate is signed by a trusted authority (CA), but does not perform any hostname verification.<br><br>`none`<br>:   Performs *no verification* of the server’s certificate. This mode disables many of the security benefits of SSL/TLS and should only be used after cautious consideration. It is primarily intended as a temporary diagnostic mechanism when attempting to resolve TLS errors; its use in production environments is strongly discouraged.<br><br>**Default:** `full`<br> |

